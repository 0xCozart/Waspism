// placehiolder for iota.go types
package iotago

import (
	"fmt"
	"math/big"

	"github.com/iotaledger/hive.go/crypto/ed25519"

	"golang.org/x/crypto/blake2b"
)

const (
	TokenTagLength = 12

	NativeTokenIDLength             = FoundryIDLength + TokenTagLength
	AliasAddressBytesLength         = 20
	AliasAddressSerializedBytesSize = 1 + AliasAddressBytesLength
	FoundryIDLength                 = AliasAddressSerializedBytesSize + 4 + 1
)

// NativeTokenID is an identifier which uniquely identifies a NativeToken.
type NativeTokenID [NativeTokenIDLength]byte

type NativeToken struct {
	ID     NativeTokenID
	Amount *big.Int
}
type NativeTokens []*NativeToken

// AddressType defines the type of addresses.
type AddressType = byte

const (
	// AddressEd25519 denotes an Ed25519 address.
	AddressEd25519 = 0
	// AddressBLS denotes a BLS address.
	AddressBLS = 1
	// AddressAlias denotes an Alias address.
	AddressAlias = 8
	// AddressNFT denotes an NFT address.
	AddressNFT = 16
)

// NetworkPrefix denotes the different network prefixes.
type NetworkPrefix string

type Address interface {
	fmt.Stringer

	// Type returns the type of the address.
	Type() AddressType

	// Bech32 encodes the address as a bech32 string.
	Bech32(hrp NetworkPrefix) string

	// Equal checks whether other is equal to this Address.
	Equal(other Address) bool
}

const TransactionIDLength = blake2b.Size256

type TransactionID = [TransactionIDLength]byte

type UTXOInput struct {
	// The transaction ID of the referenced transaction.
	TransactionID TransactionID
	// The output index of the output on the referenced transaction.
	TransactionOutputIndex uint16
}

// SimpleOutput is an output type which can be unlocked via a signature. It deposits onto one single address.
type SimpleOutput struct {
	// The actual address.
	Address Address
	// The amount of IOTA tokens held by the output.
	Amount uint64
}

const (
	// AliasIDLength is the byte length of an AliasID.
	AliasIDLength = 20
)

type AliasID [AliasIDLength]byte

// AliasOutput is an output type which represents an alias account.
type AliasOutput struct {
	// The amount of IOTA tokens held by the output.
	Amount uint64
	// The native tokens held by the output.
	NativeTokens NativeTokens
	// The identifier for this alias account.
	AliasID AliasID
	// The entity which is allowed to control this alias account state.
	StateController Address
	// The entity which is allowed to govern this alias account.
	GovernanceController Address
	// The index of the state.
	StateIndex uint32
	// The state of the alias account which can only be mutated by the state controller.
	StateMetadata []byte
	// The counter that denotes the number of foundries created by this alias account.
	FoundryCounter uint32
	// The feature blocks which modulate the constraints on the output.
	Blocks FeatureBlocks
}

type FeatureBlocks []FeatureBlock
type FeatureBlockType byte
type FeatureBlock interface {
	// Type returns the type of the FeatureBlock.
	Type() FeatureBlockType
	// Equal tells whether this FeatureBlock is equal to other.
	Equal(other FeatureBlock) bool
}

type ExtendedOutput struct {
	// The amount of IOTA tokens held by the output.
	Amount uint64
	// The native tokens held by the output.
	NativeTokens NativeTokens
	// The deposit address.
	Address Address
	// The feature blocks which modulate the constraints on the output.
	Blocks FeatureBlocks
}

const NFTIDLength = 20

type NFTID [NFTIDLength]byte

type NFTOutput struct {
	// The amount of IOTA tokens held by the output.
	Amount uint64
	// The native tokens held by the output.
	NativeTokens NativeTokens
	// The actual address.
	Address Address
	// The identifier of this NFT.
	NFTID NFTID
	// Arbitrary immutable binary data attached to this NFT.
	ImmutableMetadata []byte
	// The feature blocks which modulate the constraints on the output.
	Blocks FeatureBlocks
}

type FoundryOutput struct {
	// The amount of IOTA tokens held by the output.
	Amount uint64
	// The native tokens held by the output.
	NativeTokens NativeTokens
	// The alias controlling the foundry.
	Address Address
	// The serial number of the foundry.
	SerialNumber uint32
	// The tag which is always the last 12 bytes of the tokens generated by this foundry.
	TokenTag TokenTag
	// The circulating supply of tokens controlled by this foundry.
	CirculatingSupply *big.Int
	// The maximum supply of tokens controlled by this foundry.
	MaximumSupply *big.Int
	// The token scheme this foundry uses.
	TokenScheme TokenScheme
	// The feature blocks which modulate the constraints on the output.
	Blocks FeatureBlocks
}
type TokenTag = [TokenTagLength]byte
type TokenScheme interface {
	Type() TokenSchemeType
}
type TokenSchemeType byte

type UnknownOutput struct {
	Address Address
	Blocks  FeatureBlocks
}

// NewED25519Address creates a new ED25519Address from the given public key.
func NewED25519Address(publicKey ed25519.PublicKey) Address {
	//digest := blake2b.Sum256(publicKey[:])

	return nil
}
