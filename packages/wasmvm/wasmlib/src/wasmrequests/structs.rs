// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use wasmlib::host::*;

#[derive(Clone)]
pub struct CallRequest {
    pub contract : ScHname, 
    pub function : ScHname, 
    pub params   : , 
    pub transfer : , 
}

impl CallRequest {
    pub fn from_bytes(bytes: &[u8]) -> CallRequest {
        let mut decode = BytesDecoder::new(bytes);
        CallRequest {
            contract : decode.hname(),
            function : decode.hname(),
            params   : decode.bytes(),
            transfer : decode.bytes(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.hname(self.contract);
		encode.hname(self.function);
		encode.bytes(self.params);
		encode.bytes(self.transfer);
        return encode.data();
    }
}

#[derive(Clone, Copy)]
pub struct ImmutableCallRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableCallRequest {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> CallRequest {
        CallRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone, Copy)]
pub struct MutableCallRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableCallRequest {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &CallRequest) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> CallRequest {
        CallRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone)]
pub struct DeployRequest {
    pub description : String, 
    pub name        : String, 
    pub params      : , 
    pub prog_hash   : ScHash, 
}

impl DeployRequest {
    pub fn from_bytes(bytes: &[u8]) -> DeployRequest {
        let mut decode = BytesDecoder::new(bytes);
        DeployRequest {
            description : decode.string(),
            name        : decode.string(),
            params      : decode.bytes(),
            prog_hash   : decode.hash(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.string(&self.description);
		encode.string(&self.name);
		encode.bytes(self.params);
		encode.hash(&self.prog_hash);
        return encode.data();
    }
}

#[derive(Clone, Copy)]
pub struct ImmutableDeployRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableDeployRequest {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> DeployRequest {
        DeployRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone, Copy)]
pub struct MutableDeployRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableDeployRequest {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &DeployRequest) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> DeployRequest {
        DeployRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone)]
pub struct PostRequest {
    pub chain_id : ScChainID, 
    pub contract : ScHname, 
    pub delay    : u32, 
    pub function : ScHname, 
    pub params   : , 
    pub transfer : , 
}

impl PostRequest {
    pub fn from_bytes(bytes: &[u8]) -> PostRequest {
        let mut decode = BytesDecoder::new(bytes);
        PostRequest {
            chain_id : decode.chain_id(),
            contract : decode.hname(),
            delay    : decode.uint32(),
            function : decode.hname(),
            params   : decode.bytes(),
            transfer : decode.bytes(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.chain_id(&self.chain_id);
		encode.hname(self.contract);
		encode.uint32(self.delay);
		encode.hname(self.function);
		encode.bytes(self.params);
		encode.bytes(self.transfer);
        return encode.data();
    }
}

#[derive(Clone, Copy)]
pub struct ImmutablePostRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutablePostRequest {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> PostRequest {
        PostRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone, Copy)]
pub struct MutablePostRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutablePostRequest {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &PostRequest) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> PostRequest {
        PostRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone)]
pub struct SendRequest {
    pub address  : ScAddress, 
    pub transfer : , 
}

impl SendRequest {
    pub fn from_bytes(bytes: &[u8]) -> SendRequest {
        let mut decode = BytesDecoder::new(bytes);
        SendRequest {
            address  : decode.address(),
            transfer : decode.bytes(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.address(&self.address);
		encode.bytes(self.transfer);
        return encode.data();
    }
}

#[derive(Clone, Copy)]
pub struct ImmutableSendRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableSendRequest {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> SendRequest {
        SendRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone, Copy)]
pub struct MutableSendRequest {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableSendRequest {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &SendRequest) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> SendRequest {
        SendRequest::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}
