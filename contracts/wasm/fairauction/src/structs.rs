// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use wasmlib::host::*;
use crate::typedefs::*;

#[derive(Clone)]
pub struct Auction {
    pub color          : ScColor,  // color of tokens for sale
    pub creator        : ScAgentID,  // issuer of start_auction transaction
    pub deposit        : u64,  // deposit by auction owner to cover the SC fees
    pub description    : String,  // auction description
    pub duration       : u32,  // auction duration in minutes
    pub highest_bid    : u64,  // the current highest bid amount
    pub highest_bidder : ScAgentID,  // the current highest bidder
    pub minimum_bid    : u64,  // minimum bid amount
    pub num_tokens     : u64,  // number of tokens for sale
    pub owner_margin   : u64,  // auction owner's margin in promilles
    pub when_started   : u64,  // timestamp when auction started
}

impl Auction {
    pub fn from_bytes(bytes: &[u8]) -> Auction {
        let mut decode = BytesDecoder::new(bytes);
        Auction {
            color          : decode.color(),
            creator        : decode.agent_id(),
            deposit        : decode.uint64(),
            description    : decode.string(),
            duration       : decode.uint32(),
            highest_bid    : decode.uint64(),
            highest_bidder : decode.agent_id(),
            minimum_bid    : decode.uint64(),
            num_tokens     : decode.uint64(),
            owner_margin   : decode.uint64(),
            when_started   : decode.uint64(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.color(&self.color);
		encode.agent_id(&self.creator);
		encode.uint64(self.deposit);
		encode.string(&self.description);
		encode.uint32(self.duration);
		encode.uint64(self.highest_bid);
		encode.agent_id(&self.highest_bidder);
		encode.uint64(self.minimum_bid);
		encode.uint64(self.num_tokens);
		encode.uint64(self.owner_margin);
		encode.uint64(self.when_started);
        return encode.data();
    }
}

#[derive(Clone, Copy)]
pub struct ImmutableAuction {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableAuction {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> Auction {
        Auction::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone, Copy)]
pub struct MutableAuction {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableAuction {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &Auction) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> Auction {
        Auction::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone)]
pub struct Bid {
    pub amount    : u64,  // cumulative amount of bids from same bidder
    pub index     : u32,  // index of bidder in bidder list
    pub timestamp : u64,  // timestamp of most recent bid
}

impl Bid {
    pub fn from_bytes(bytes: &[u8]) -> Bid {
        let mut decode = BytesDecoder::new(bytes);
        Bid {
            amount    : decode.uint64(),
            index     : decode.uint32(),
            timestamp : decode.uint64(),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut encode = BytesEncoder::new();
		encode.uint64(self.amount);
		encode.uint32(self.index);
		encode.uint64(self.timestamp);
        return encode.data();
    }
}

#[derive(Clone, Copy)]
pub struct ImmutableBid {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl ImmutableBid {
    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn value(&self) -> Bid {
        Bid::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}

#[derive(Clone, Copy)]
pub struct MutableBid {
    pub(crate) obj_id: i32,
    pub(crate) key_id: Key32,
}

impl MutableBid {
    pub fn delete(&self) {
        del_key(self.obj_id, self.key_id, TYPE_BYTES);
    }

    pub fn exists(&self) -> bool {
        exists(self.obj_id, self.key_id, TYPE_BYTES)
    }

    pub fn set_value(&self, value: &Bid) {
        set_bytes(self.obj_id, self.key_id, TYPE_BYTES, &value.to_bytes());
    }

    pub fn value(&self) -> Bid {
        Bid::from_bytes(&get_bytes(self.obj_id, self.key_id, TYPE_BYTES))
    }
}
