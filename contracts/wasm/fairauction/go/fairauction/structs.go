// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

package fairauction

import "github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib/wasmtypes"

type Auction struct {
	Creator       wasmtypes.ScAgentID
	Deposit       uint64
	Description   string
	Duration      uint32
	HighestBid    uint64
	HighestBidder wasmtypes.ScAgentID
	MinimumBid    uint64
	NumTokens     uint64
	OwnerMargin   uint64
	Token         wasmtypes.ScTokenID // token of tokens for sale
	// issuer of start_auction transaction
	// deposit by auction owner to cover the SC fees
	// auction description
	// auction duration in minutes
	// the current highest bid amount
	// the current highest bidder
	// minimum bid amount
	// number of tokens for sale
	// auction owner's margin in promilles
	// timestamp when auction started
	WhenStarted uint64
}

func NewAuctionFromBytes(buf []byte) *Auction {
	dec := wasmtypes.NewWasmDecoder(buf)
	data := &Auction{}
	data.Creator = wasmtypes.AgentIDDecode(dec)
	data.Deposit = wasmtypes.Uint64Decode(dec)
	data.Description = wasmtypes.StringDecode(dec)
	data.Duration = wasmtypes.Uint32Decode(dec)
	data.HighestBid = wasmtypes.Uint64Decode(dec)
	data.HighestBidder = wasmtypes.AgentIDDecode(dec)
	data.MinimumBid = wasmtypes.Uint64Decode(dec)
	data.NumTokens = wasmtypes.Uint64Decode(dec)
	data.OwnerMargin = wasmtypes.Uint64Decode(dec)
	data.Token = wasmtypes.TokenIDDecode(dec)
	data.WhenStarted = wasmtypes.Uint64Decode(dec)
	dec.Close()
	return data
}

func (o *Auction) Bytes() []byte {
	enc := wasmtypes.NewWasmEncoder()
	wasmtypes.AgentIDEncode(enc, o.Creator)
	wasmtypes.Uint64Encode(enc, o.Deposit)
	wasmtypes.StringEncode(enc, o.Description)
	wasmtypes.Uint32Encode(enc, o.Duration)
	wasmtypes.Uint64Encode(enc, o.HighestBid)
	wasmtypes.AgentIDEncode(enc, o.HighestBidder)
	wasmtypes.Uint64Encode(enc, o.MinimumBid)
	wasmtypes.Uint64Encode(enc, o.NumTokens)
	wasmtypes.Uint64Encode(enc, o.OwnerMargin)
	wasmtypes.TokenIDEncode(enc, o.Token)
	wasmtypes.Uint64Encode(enc, o.WhenStarted)
	return enc.Buf()
}

type ImmutableAuction struct {
	proxy wasmtypes.Proxy
}

func (o ImmutableAuction) Exists() bool {
	return o.proxy.Exists()
}

func (o ImmutableAuction) Value() *Auction {
	return NewAuctionFromBytes(o.proxy.Get())
}

type MutableAuction struct {
	proxy wasmtypes.Proxy
}

func (o MutableAuction) Delete() {
	o.proxy.Delete()
}

func (o MutableAuction) Exists() bool {
	return o.proxy.Exists()
}

func (o MutableAuction) SetValue(value *Auction) {
	o.proxy.Set(value.Bytes())
}

func (o MutableAuction) Value() *Auction {
	return NewAuctionFromBytes(o.proxy.Get())
}

type Bid struct {
	Amount uint64 // cumulative amount of bids from same bidder
	// index of bidder in bidder list
	// timestamp of most recent bid
	Index     uint32
	Timestamp uint64
}

func NewBidFromBytes(buf []byte) *Bid {
	dec := wasmtypes.NewWasmDecoder(buf)
	data := &Bid{}
	data.Amount = wasmtypes.Uint64Decode(dec)
	data.Index = wasmtypes.Uint32Decode(dec)
	data.Timestamp = wasmtypes.Uint64Decode(dec)
	dec.Close()
	return data
}

func (o *Bid) Bytes() []byte {
	enc := wasmtypes.NewWasmEncoder()
	wasmtypes.Uint64Encode(enc, o.Amount)
	wasmtypes.Uint32Encode(enc, o.Index)
	wasmtypes.Uint64Encode(enc, o.Timestamp)
	return enc.Buf()
}

type ImmutableBid struct {
	proxy wasmtypes.Proxy
}

func (o ImmutableBid) Exists() bool {
	return o.proxy.Exists()
}

func (o ImmutableBid) Value() *Bid {
	return NewBidFromBytes(o.proxy.Get())
}

type MutableBid struct {
	proxy wasmtypes.Proxy
}

func (o MutableBid) Delete() {
	o.proxy.Delete()
}

func (o MutableBid) Exists() bool {
	return o.proxy.Exists()
}

func (o MutableBid) SetValue(value *Bid) {
	o.proxy.Set(value.Bytes())
}

func (o MutableBid) Value() *Bid {
	return NewBidFromBytes(o.proxy.Get())
}
